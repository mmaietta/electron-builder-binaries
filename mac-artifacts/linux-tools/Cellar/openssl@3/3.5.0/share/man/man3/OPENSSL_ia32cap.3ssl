.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OPENSSL_IA32CAP 3ssl"
.TH OPENSSL_IA32CAP 3ssl "2025-04-08" "3.5.0" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OPENSSL_ia32cap \- the x86[_64] processor capabilities vector
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& env OPENSSL_ia32cap=... <application>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
OpenSSL supports a range of x86[_64] instruction set extensions and
features. These extensions are denoted by individual bits or groups of bits
stored internally as ten 32\-bit capability vectors and for simplicity
represented logically below as five 64\-bit vectors. This logical
vector (\s-1LV\s0) representation is used to streamline the definition of the
OPENSSL_ia32cap environment variable.
.PP
Upon toolkit initialization, the capability vectors are populated through
successive executions of the \s-1CPUID\s0 instruction, after which any OPENSSL_ia32cap
environment variable capability bit modifications are applied. After toolkit
initialization is complete, populated vectors are then used to choose
between different code paths to provide optimal performance across a wide
range of x86[_64] based processors.
.PP
Further \s-1CPUID\s0 information can be found in the Intel(R) Architecture
Instruction Set Extensions Programming Reference, and the \s-1AMD64\s0 Architecture
Programmer's Manual (Volume 3).
.SS "Notable Capability Bits for \s-1LV0\s0"
.IX Subsection "Notable Capability Bits for LV0"
The following are notable capability bits from logical vector 0 (\s-1LV0\s0)
resulting from the following execution of \s-1CPUID.\s0(EAX=01H).EDX and
\&\s-1CPUID.\s0(EAX=01H).ECX:
.IP "bit #0+4 denoting presence of Time-Stamp Counter;" 4
.IX Item "bit #0+4 denoting presence of Time-Stamp Counter;"
.PD 0
.IP "bit #0+19 denoting availability of \s-1CLFLUSH\s0 instruction;" 4
.IX Item "bit #0+19 denoting availability of CLFLUSH instruction;"
.IP "bit #0+20, reserved by Intel, is used to choose among \s-1RC4\s0 code paths;" 4
.IX Item "bit #0+20, reserved by Intel, is used to choose among RC4 code paths;"
.IP "bit #0+23 denoting \s-1MMX\s0 support;" 4
.IX Item "bit #0+23 denoting MMX support;"
.IP "bit #0+24, \s-1FXSR\s0 bit, denoting availability of \s-1XMM\s0 registers;" 4
.IX Item "bit #0+24, FXSR bit, denoting availability of XMM registers;"
.IP "bit #0+25 denoting \s-1SSE\s0 support;" 4
.IX Item "bit #0+25 denoting SSE support;"
.IP "bit #0+26 denoting \s-1SSE2\s0 support;" 4
.IX Item "bit #0+26 denoting SSE2 support;"
.IP "bit #0+28 denoting Hyperthreading, which is used to distinguish cores with shared cache;" 4
.IX Item "bit #0+28 denoting Hyperthreading, which is used to distinguish cores with shared cache;"
.IP "bit #0+30, reserved by Intel, denotes specifically Intel CPUs;" 4
.IX Item "bit #0+30, reserved by Intel, denotes specifically Intel CPUs;"
.IP "bit #0+33 denoting availability of \s-1PCLMULQDQ\s0 instruction;" 4
.IX Item "bit #0+33 denoting availability of PCLMULQDQ instruction;"
.IP "bit #0+41 denoting \s-1SSSE3,\s0 Supplemental \s-1SSE3,\s0 support;" 4
.IX Item "bit #0+41 denoting SSSE3, Supplemental SSE3, support;"
.IP "bit #0+43 denoting \s-1AMD XOP\s0 support (forced to zero on non-AMD CPUs);" 4
.IX Item "bit #0+43 denoting AMD XOP support (forced to zero on non-AMD CPUs);"
.IP "bit #0+54 denoting availability of \s-1MOVBE\s0 instruction;" 4
.IX Item "bit #0+54 denoting availability of MOVBE instruction;"
.IP "bit #0+57 denoting AES-NI instruction set extension;" 4
.IX Item "bit #0+57 denoting AES-NI instruction set extension;"
.IP "bit #0+58, \s-1XSAVE\s0 bit, lack of which in combination with \s-1MOVBE\s0 is used to identify Atom Silvermont core;" 4
.IX Item "bit #0+58, XSAVE bit, lack of which in combination with MOVBE is used to identify Atom Silvermont core;"
.IP "bit #0+59, \s-1OSXSAVE\s0 bit, denoting availability of \s-1YMM\s0 registers;" 4
.IX Item "bit #0+59, OSXSAVE bit, denoting availability of YMM registers;"
.IP "bit #0+60 denoting \s-1AVX\s0 extension;" 4
.IX Item "bit #0+60 denoting AVX extension;"
.IP "bit #0+62 denoting availability of \s-1RDRAND\s0 instruction;" 4
.IX Item "bit #0+62 denoting availability of RDRAND instruction;"
.PD
.SS "Notable Capability Bits for \s-1LV1\s0"
.IX Subsection "Notable Capability Bits for LV1"
The following are notable capability bits from logical vector 1 (\s-1LV1\s0)
resulting from the following execution of \s-1CPUID.\s0(EAX=07H,ECX=0H).EBX and
\&\s-1CPUID.\s0(EAX=07H,ECX=0H).ECX:
.IP "bit #64+3 denoting availability of \s-1BMI1\s0 instructions, e.g. \s-1ANDN\s0;" 4
.IX Item "bit #64+3 denoting availability of BMI1 instructions, e.g. ANDN;"
.PD 0
.IP "bit #64+5 denoting availability of \s-1AVX2\s0 instructions;" 4
.IX Item "bit #64+5 denoting availability of AVX2 instructions;"
.IP "bit #64+8 denoting availability of \s-1BMI2\s0 instructions, e.g. \s-1MULX\s0 and \s-1RORX\s0;" 4
.IX Item "bit #64+8 denoting availability of BMI2 instructions, e.g. MULX and RORX;"
.IP "bit #64+16 denoting availability of \s-1AVX512F\s0 extension;" 4
.IX Item "bit #64+16 denoting availability of AVX512F extension;"
.IP "bit #64+17 denoting availability of \s-1AVX512DQ\s0 extension;" 4
.IX Item "bit #64+17 denoting availability of AVX512DQ extension;"
.IP "bit #64+18 denoting availability of \s-1RDSEED\s0 instruction;" 4
.IX Item "bit #64+18 denoting availability of RDSEED instruction;"
.IP "bit #64+19 denoting availability of \s-1ADCX\s0 and \s-1ADOX\s0 instructions;" 4
.IX Item "bit #64+19 denoting availability of ADCX and ADOX instructions;"
.IP "bit #64+21 denoting availability of \s-1AVX512IFMA\s0 extension;" 4
.IX Item "bit #64+21 denoting availability of AVX512IFMA extension;"
.IP "bit #64+29 denoting availability of \s-1SHA\s0 extension;" 4
.IX Item "bit #64+29 denoting availability of SHA extension;"
.IP "bit #64+30 denoting availability of \s-1AVX512BW\s0 extension;" 4
.IX Item "bit #64+30 denoting availability of AVX512BW extension;"
.IP "bit #64+31 denoting availability of \s-1AVX512VL\s0 extension;" 4
.IX Item "bit #64+31 denoting availability of AVX512VL extension;"
.IP "bit #64+41 denoting availability of \s-1VAES\s0 extension;" 4
.IX Item "bit #64+41 denoting availability of VAES extension;"
.IP "bit #64+42 denoting availability of \s-1VPCLMULQDQ\s0 extension;" 4
.IX Item "bit #64+42 denoting availability of VPCLMULQDQ extension;"
.PD
.SS "Notable Capability Bits for \s-1LV2\s0"
.IX Subsection "Notable Capability Bits for LV2"
The following are notable capability bits from logical vector 2 (\s-1LV2\s0)
resulting from the following execution of \s-1CPUID.\s0(EAX=07H,ECX=0H).EDX and
\&\s-1CPUID.\s0(EAX=07H,ECX=1H).EAX:
.IP "bit #128+15 denoting availability of Hybrid \s-1CPU\s0;" 4
.IX Item "bit #128+15 denoting availability of Hybrid CPU;"
.PD 0
.IP "bit #128+29 denoting support for \s-1IA32_ARCH_CAPABILITIES MSR\s0;" 4
.IX Item "bit #128+29 denoting support for IA32_ARCH_CAPABILITIES MSR;"
.IP "bit #128+32 denoting availability of \s-1SHA512\s0 extension;" 4
.IX Item "bit #128+32 denoting availability of SHA512 extension;"
.IP "bit #128+33 denoting availability of \s-1SM3\s0 extension;" 4
.IX Item "bit #128+33 denoting availability of SM3 extension;"
.IP "bit #128+34 denoting availability of \s-1SM4\s0 extension;" 4
.IX Item "bit #128+34 denoting availability of SM4 extension;"
.IP "bit #128+55 denoting availability of AVX-IFMA extension;" 4
.IX Item "bit #128+55 denoting availability of AVX-IFMA extension;"
.PD
.SS "Notable Capability Bits for \s-1LV3\s0"
.IX Subsection "Notable Capability Bits for LV3"
The following are notable capability bits from logical vector 3 (\s-1LV3\s0)
resulting from the following execution of \s-1CPUID.\s0(EAX=07H,ECX=1H).EDX and
\&\s-1CPUID.\s0(EAX=07H,ECX=1H).EBX:
.IP "bit #192+19 denoting availability of \s-1AVX10\s0 Converged Vector \s-1ISA\s0 extension;" 4
.IX Item "bit #192+19 denoting availability of AVX10 Converged Vector ISA extension;"
.PD 0
.IP "bit #192+21 denoting availability of \s-1APX_F\s0 extension;" 4
.IX Item "bit #192+21 denoting availability of APX_F extension;"
.PD
.SS "Notable Capability Bits for \s-1LV4\s0"
.IX Subsection "Notable Capability Bits for LV4"
The following are notable capability bits from logical vector 4 (\s-1LV4\s0)
resulting from the following execution of \s-1CPUID.\s0(EAX=07H,ECX=1H).ECX and
\&\s-1CPUID.\s0(EAX=24H,ECX=0H).EBX:
.IP "bits #256+32+[0:7] denoting \s-1AVX10\s0 Converged Vector \s-1ISA\s0 Version (8 bits);" 4
.IX Item "bits #256+32+[0:7] denoting AVX10 Converged Vector ISA Version (8 bits);"
.PD 0
.IP "bit #256+48 denoting \s-1AVX10 XMM\s0 support;" 4
.IX Item "bit #256+48 denoting AVX10 XMM support;"
.IP "bit #256+49 denoting \s-1AVX10 YMM\s0 support;" 4
.IX Item "bit #256+49 denoting AVX10 YMM support;"
.IP "bit #256+50 denoting \s-1AVX10 ZMM\s0 support;" 4
.IX Item "bit #256+50 denoting AVX10 ZMM support;"
.PD
.SS "OPENSSL_ia32cap environment variable"
.IX Subsection "OPENSSL_ia32cap environment variable"
The \fBOPENSSL_ia32cap\fR environment variable provides a mechanism to override
the default capability vector values at library initialization time.
The variable consists of a series of 64\-bit numbers representing each
of the logical vectors (\s-1LV\s0) described above. Each value is delimited by a '\fB:\fR'.
Decimal/Octal/Hexadecimal values representations are supported.
.PP
\&\f(CW\*(C`env OPENSSL_ia32cap=LV0:LV1:LV2:LV3:LV4\*(C'\fR
.PP
Used in this form, each non-null logical vector will *overwrite* the entire corresponding
capability vector pair with the provided value. To keep compatibility with the
behaviour of the original OPENSSL_ia32cap environment variable
<env OPENSSL_ia32cap=LV0:LV1>, the next capability vector pairs will be set to zero.
.PP
To illustrate, the following will zero all capability bits in logical vectors 1 and further
(disable all post-AVX extensions):
.PP
\&\f(CW\*(C`env OPENSSL_ia32cap=:0\*(C'\fR
.PP
The following will zero all capability bits in logical vectors 2 and further:
.PP
\&\f(CW\*(C`env OPENSSL_ia32cap=::0\*(C'\fR
.PP
The following will zero all capability bits only in logical vector 1:
\&\f(CW\*(C`env OPENSSL_ia32cap=:0::::\*(C'\fR
.PP
A more likely usage scenario would be to disable specific instruction set extensions.
The '\fB~\fR' character is used to specify a bit mask of the extensions to be disabled for
a particular logical vector.
.PP
To illustrate, the following will disable \s-1AVX2\s0 code paths and further extensions:
.PP
\&\f(CW\*(C`env OPENSSL_ia32cap=:~0x20000000000\*(C'\fR
.PP
The following will disable \s-1AESNI\s0 (\s-1LV0\s0 bit 57) and \s-1VAES\s0 (\s-1LV1\s0 bit 41)
extensions and therefore any code paths using those extensions but leave
the rest of the logical vectors unchanged:
.PP
\&\f(CW\*(C`env OPENSSL_ia32cap=~0x200000000000000:~0x20000000000:~0x0:~0x0:~0x0\*(C'\fR
.SH "NOTES"
.IX Header "NOTES"
Not all capability bits are copied from \s-1CPUID\s0 output verbatim. An example
of this is the somewhat less intuitive clearing of \s-1LV0\s0 bit #28, or ~0x10000000
in the \*(L"environment variable\*(R" terms. It has been adjusted to reflect whether or
not the data cache is actually shared between logical cores. This in turn affects
the decision on whether or not expensive countermeasures against cache-timing attacks
are applied, most notably in \s-1AES\s0 assembler module.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
Not available.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004\-2021 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
