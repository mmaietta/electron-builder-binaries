.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_SET_QUIC_TLS_CBS 3ssl"
.TH SSL_SET_QUIC_TLS_CBS 3ssl "2025-04-08" "3.5.0" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OSSL_FUNC_SSL_QUIC_TLS_crypto_send_fn,
OSSL_FUNC_SSL_QUIC_TLS_crypto_recv_rcd_fn,
OSSL_FUNC_SSL_QUIC_TLS_crypto_release_rcd_fn,
OSSL_FUNC_SSL_QUIC_TLS_yield_secret_fn,
OSSL_FUNC_SSL_QUIC_TLS_got_transport_params_fn,
OSSL_FUNC_SSL_QUIC_TLS_alert_fn,
SSL_set_quic_tls_cbs,
SSL_set_quic_tls_transport_params,
SSL_set_quic_tls_early_data_enabled
\&\- Use the OpenSSL TLS implementation for a third party QUIC implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& /* QUIC TLS callbacks available via an OSSL_DISPATCH table */
\&
\& /* Function id: OSSL_FUNC_SSL_QUIC_TLS_CRYPTO_SEND */
\& typedef int (*OSSL_FUNC_SSL_QUIC_TLS_crypto_send_fn)(SSL *s,
\&                                                      const unsigned char *buf,
\&                                                      size_t buf_len,
\&                                                      size_t *consumed,
\&                                                      void *arg);
\&
\& /* Function id: OSSL_FUNC_SSL_QUIC_TLS_CRYPTO_RECV_RCD */
\& typedef int (*OSSL_FUNC_SSL_QUIC_TLS_crypto_recv_rcd_fn)(SSL *s,
\&                                                    const unsigned char **buf,
\&                                                    size_t *bytes_read,
\&                                                    void *arg);
\&
\& /* Function id: OSSL_FUNC_SSL_QUIC_TLS_CRYPTO_RELEASE_RCD */
\& typedef int (*OSSL_FUNC_SSL_QUIC_TLS_crypto_release_rcd_fn)(SSL *,
\&                                                             size_t bytes_read,
\&                                                             void *arg);
\&
\& /* Function id: OSSL_FUNC_SSL_QUIC_TLS_YIELD_SECRET */
\& typedef int (*OSSL_FUNC_SSL_QUIC_TLS_yield_secret_fn)(SSL *s,
\&                                                    uint32_t prot_level,
\&                                                    int direction,
\&                                                    const unsigned char *secret,
\&                                                    size_t secret_len,
\&                                                    void *arg);
\&
\& /* Function id: OSSL_FUNC_SSL_QUIC_TLS_GOT_TRANSPORT_PARAMS */
\& typedef int (*OSSL_FUNC_SSL_QUIC_TLS_got_transport_params_fn)(SSL *s,
\&                                                    const unsigned char *params,
\&                                                    size_t params_len,
\&                                                    void *arg);
\&
\& /* Function id: OSSL_FUNC_SSL_QUIC_TLS_ALERT */
\& typedef int (*OSSL_FUNC_SSL_QUIC_TLS_alert_fn)(SSL *s,
\&                                                unsigned char alert_code,
\&                                                void *arg);
\&
\& int SSL_set_quic_tls_cbs(SSL *s, const OSSL_DISPATCH *qtdis, void *arg);
\& int SSL_set_quic_tls_transport_params(SSL *s,
\&                                       const unsigned char *params,
\&                                       size_t params_len);
\& int SSL_set_quic_tls_early_data_enabled(SSL *s, int enabled);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBSSL_set_quic_tls_cbs()\fR can be used to replace the standard \s-1TLS\s0 record layer with
a custom record layer for use by a third party \s-1QUIC\s0 implementation. For the
given \s-1SSL\s0 object \fIs\fR, a set of callbacks are supplied in an \fB\s-1OSSL_DISPATCH\s0\fR
table via \fIqtdis\fR. The \fIarg\fR parameter will be passed as an argument when the
various callbacks are called.
.PP
An \fB\s-1OSSL_DISPATCH\s0\fR table should consist of an array of \fB\s-1OSSL_DISPATCH\s0\fR entries
where each entry is a function id, and a function pointer. The array should be
terminated with an empty entry (i.e. a 0 function id, and a \s-1NULL\s0 function
pointer).
.PP
Calling the \fBSSL_set_quic_tls_cbs()\fR function will switch off the
\&\fB\s-1SSL_OP_ENABLE_MIDDLEBOX_COMPAT\s0\fR option (if set). See \fBSSL_set_options\fR\|(3).
Additionally the minimum \s-1TLS\s0 protocol version will be set to \s-1TLS1_3_VERSION.\s0 It
is an error to call this function with anything other than a \s-1TLS\s0 connection \s-1SSL\s0
object.
.PP
The OSSL_FUNC_SSL_QUIC_TLS_crypto_send_fn callback (function id
\&\fB\s-1OSSL_FUNC_SSL_QUIC_TLS_CRYPTO_SEND\s0\fR) is called when \s-1CRYPTO\s0 frame data should
be sent to the peer. The data to be sent is supplied in the buffer \fIbuf\fR which
is of length \fIbuf_len\fR. The callback may choose to consume less data than was
supplied in the buffer. On successful completion of the callback the \fIconsumed\fR
parameter should be populated with the amount of data that the callback
consumed. This should be less than or equal to the value in \fIbuf_len\fR. \s-1CRYPTO\s0
data should be sent using the most recent write encryption level set via the
OSSL_FUNC_SSL_QUIC_TLS_yield_secret_fn callback (if it has been called).
.PP
The OSSL_FUNC_SSL_QUIC_TLS_crypto_recv_rcd_fn callback (function id
\&\fB\s-1OSSL_FUNC_SSL_QUIC_TLS_CRYPTO_RECV_RCD\s0\fR) is used to receive \s-1CRYPTO\s0 frame data
from the peer. When OpenSSL wants to read data from the peer this callback is
called. The callback should populate \fI*buf\fR with a pointer to a buffer
containing \s-1CRYPTO\s0 data that has been received from the peer. The size of the
buffer should be populated in \fI*bytes_read\fR. The buffer should remain valid
until OpenSSL calls the OSSL_FUNC_SSL_QUIC_TLS_crypto_release_rcd_fn callback.
\&\s-1CRYPTO\s0 frame data is assumed to have been decrypted using the most recent read
protection level set via the yield_secret_cb callback (if it has been called).
.PP
The OSSL_FUNC_SSL_QUIC_TLS_crypto_release_rcd_fn callback (function id
\&\fB\s-1OSSL_FUNC_SSL_QUIC_TLS_CRYPTO_RELEASE_RCD\s0\fR) is called when data previously
read via OSSL_FUNC_SSL_QUIC_TLS_crypto_recv_rcd_fn is no longer required. The
\&\fIbytes_read\fR argument is always equal to the size of the buffer previously
provided in the crypto_receive_rcd_cb callback. Only one record at a time will
ever be read by OpenSSL.
.PP
The OSSL_FUNC_SSL_QUIC_TLS_yield_secret_fn callback (function id
\&\fB\s-1OSSL_FUNC_SSL_QUIC_TLS_YIELD_SECRET\s0\fR) is called when a new secret has been
established. The \fIprot_level\fR argument identies the \s-1TLS\s0 protection level and
will be one of \fB\s-1OSSL_RECORD_PROTECTION_LEVEL_NONE\s0\fR,
\&\fB\s-1OSSL_RECORD_PROTECTION_LEVEL_EARLY\s0\fR, \fB\s-1OSSL_RECORD_PROTECTION_LEVEL_HANDSHAKE\s0\fR
or \fB\s-1OSSL_RECORD_PROTECTION_LEVEL_APPLICATION\s0\fR. The \fIdirection\fR will either be
0 (for the read secret) or 1 (for the write secret). The secret itself will
be in the buffer pointed to by \fIsecret\fR and the buffer will be of length
\&\fIsecret_len\fR.
.PP
The OSSL_FUNC_SSL_QUIC_TLS_got_transport_params_fn callback (function id
\&\fB\s-1OSSL_FUNC_SSL_QUIC_TLS_GOT_TRANSPORT_PARAMS\s0\fR) is called when transport
parameters have been received from the peer. The parameters are held in the
\&\fIparams\fR buffer which is of length \fIparams_len\fR.
.PP
The OSSL_FUNC_SSL_QUIC_TLS_alert_fn callback (function id
\&\fB\s-1OSSL_FUNC_SSL_QUIC_TLS_ALERT\s0\fR) is called when OpenSSL is attempting to send an
alert to the peer. The code for the alert is supplied in \fIalert_code\fR.
.PP
The \fBSSL_set_quic_tls_transport_params()\fR function is used to set the transport
parameters to be sent by this endpoint. The parameters are in the \fIparams\fR
buffer which should be of length \fIparams_len\fR. The buffer containing the
parameters should remain valid until after the parameters have been sent. This
function must have been called by the time the transport parameters need to be
sent. For a client this will be before the connection has been initiated. For a
server this might typically occur during the got_transport_params_cb.
.PP
The \fBSSL_set_quic_tls_early_data_enabled()\fR function is used to enable the 0\-RTT
feature for a third party \s-1QUIC\s0 implementation.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
These functions return 1 on success and 0 on failure.
.PP
All of the callbacks should also return 1 on success and 0 on failure. A
failure response is fatal to the connection.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
A call to \fBSSL_set_quic_tls_cbs()\fR might look something like the following, given
suitable definitions of the various callback functions:
.PP
.Vb 10
\& const OSSL_DISPATCH qtdis[] = {
\&     {OSSL_FUNC_SSL_QUIC_TLS_CRYPTO_SEND, (void (*)(void))crypto_send_cb},
\&     {OSSL_FUNC_SSL_QUIC_TLS_CRYPTO_RECV_RCD,
\&         (void (*)(void))crypto_recv_rcd_cb},
\&     {OSSL_FUNC_SSL_QUIC_TLS_CRYPTO_RELEASE_RCD,
\&         (void (*)(void))crypto_release_rcd_cb},
\&     {OSSL_FUNC_SSL_QUIC_TLS_YIELD_SECRET,
\&         (void (*)(void))yield_secret_cb},
\&     {OSSL_FUNC_SSL_QUIC_TLS_GOT_TRANSPORT_PARAMS,
\&         (void (*)(void))got_transport_params_cb},
\&     {OSSL_FUNC_SSL_QUIC_TLS_ALERT, (void (*)(void))alert_cb},
\&     {0, NULL}
\&  };
\&
\& if (!SSL_set_quic_tls_cbs(ssl, qtdis, NULL))
\&     goto err;
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
These functions were added in OpenSSL 3.5.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2024\-2025 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
